# 컴퓨터 네트워크 기본 1

## 문제 1: 스위칭 방식 중 회선 교환과 패킷 교환의 차이점을 설명하시오.

- **회선 교환**: 
    - 통신 경로를 미리 설정
    - 경로 독점
    - 고정 대역폭 제공
    - 예: 전화망

- **패킷 교환**:
    - 데이터 패킷을 개별적으로 전송
    - 경로 공유
    - 가변 대역폭 제공
    - 예: 인터넷

## 문제 2: 네트워크에서 패킷 지연의 네 가지 주요 원인에 대해 설명하시오.

1. **전송 지연 (Transmission Delay)**:
    - **설명**: 패킷의 모든 비트를 전송 매체에 보내는 데 걸리는 시간입니다. 패킷 크기와 링크의 전송 속도에 따라 달라집니다.
    - **공식**: 
      \[
      \text{Transmission Delay} = \frac{\text{Packet Size}}{\text{Transmission Rate}}
      \]
    - **예시**: 1,000비트 패킷을 1Mbps 링크를 통해 전송할 경우 전송 지연은 1밀리초입니다.

2. **전파 지연 (Propagation Delay)**:
    - **설명**: 패킷이 송신지에서 수신지까지 이동하는 데 걸리는 시간입니다. 전파 속도와 링크의 길이에 따라 달라집니다.
    - **공식**: 
      \[
      \text{Propagation Delay} = \frac{\text{Distance}}{\text{Propagation Speed}}
      \]
    - **예시**: 2,000km 떨어진 위치에 패킷을 보낼 때, 전파 속도가 빛의 속도의 2/3일 경우 전파 지연은 약 10밀리초입니다.

3. **처리 지연 (Processing Delay)**:
    - **설명**: 라우터나 스위치에서 패킷 헤더를 처리하고 적절한 경로로 전달하기 위해 검사하는 데 걸리는 시간입니다.
    - **예시**: 패킷이 라우터에 도착했을 때, 라우터가 패킷을 분석하고 라우팅 테이블을 조회하여 다음 홉을 결정하는 데 걸리는 시간은 처리 지연입니다. 일반적으로 수 밀리초에서 수십 밀리초가 소요됩니다.

4. **큐잉 지연 (Queuing Delay)**:
    - **설명**: 패킷이 라우터나 스위치의 큐에서 대기하는 시간입니다. 네트워크 트래픽의 양에 따라 달라집니다.
    - **예시**: 네트워크가 혼잡한 경우, 패킷이 라우터의 출력 큐에서 기다려야 하는 시간이 길어질 수 있습니다. 트래픽이 많을수록 큐잉 지연이 증가합니다.

# 컴퓨터 네트워크 기본 2

## 문제 1: 애플리케이션에서 필요한 전송 서비스(Transport Service)의 종류와 그 필요성에 대해 설명하시오.

애플리케이션이 필요로 하는 전송 서비스는 애플리케이션의 성격과 요구 사항에 따라 다릅니다. 전송 서비스는 주로 **신뢰성**, **데이터 전송 속도**, **지연 시간**, **보안** 등 여러 요소에 따라 결정됩니다. 주요 전송 서비스와 그 필요성은 다음과 같습니다:

1. **신뢰성 (Reliability)**:
    - **필요성**: 데이터 전송 과정에서 손실, 오류, 중복을 방지하고 정확한 데이터 전송을 보장하기 위해 신뢰성이 중요합니다.
    - **프로토콜**: **TCP (Transmission Control Protocol)**
        - TCP는 연결 지향적이며, 데이터의 정확한 전달을 보장합니다. 오류 검출, 데이터 재전송, 데이터 순서 제어 기능을 제공합니다.
    - **적용 사례**: 웹 브라우징, 파일 전송, 이메일

2. **전송 속도 (Speed)**:
    - **필요성**: 데이터 전송 속도가 중요한 실시간 애플리케이션에서는 높은 전송 속도가 필요합니다.
    - **프로토콜**: **UDP (User Datagram Protocol)**
        - UDP는 연결 비지향적이며, 빠른 데이터 전송을 제공합니다. 신뢰성 보장은 없지만, 지연 시간이 최소화됩니다.
    - **적용 사례**: 실시간 스트리밍, 온라인 게임, VoIP

3. **지연 시간 (Latency)**:
    - **필요성**: 낮은 지연 시간이 중요한 애플리케이션에서는 신속한 데이터 전송이 필요합니다.
    - **프로토콜**: **UDP**
        - UDP는 지연 시간이 적어, 실시간 데이터 전송에 적합합니다.
    - **적용 사례**: 실시간 통신, 라이브 비디오 스트리밍

4. **혼잡 제어 (Congestion Control)**:
    - **필요성**: 네트워크 혼잡을 관리하여 데이터 전송 효율성을 높이고, 네트워크 전반의 성능 저하를 방지합니다.
    - **프로토콜**: **TCP**
        - TCP는 혼잡 제어 알고리즘을 사용하여 네트워크 상태에 따라 데이터 전송 속도를 조절합니다.
    - **적용 사례**: 안정적인 데이터 전송이 필요한 모든 애플리케이션

5. **보안 (Security)**:
    - **필요성**: 데이터 전송 중 보안을 유지하고, 데이터의 무결성과 기밀성을 보장합니다.
    - **프로토콜**: **TLS (Transport Layer Security)**
        - TLS는 TCP와 함께 사용되어 데이터 암호화와 무결성을 보장합니다.
    - **적용 사례**: 온라인 금융 거래, 민감한 데이터 전송

6. **멀티캐스트 (Multicast)**:
    - **필요성**: 여러 수신자에게 동시에 데이터를 전송할 필요가 있는 애플리케이션에서 중요합니다.
    - **프로토콜**: **UDP Multicast**
        - UDP 멀티캐스트는 하나의 송신자가 여러 수신자에게 동시에 데이터를 전송할 수 있게 합니다.
    - **적용 사례**: 라이브 비디오 컨퍼런스, 주식 시세 전송

**요약**: 애플리케이션의 특성과 요구 사항에 따라 TCP와 UDP를 비롯한 다양한 전송 서비스가 필요합니다. TCP는 신뢰성과 혼잡 제어가 중요한 애플리케이션에 적합하며, UDP는 빠른 전송과 낮은 지연 시간이 필요한 실시간 애플리케이션에 적합합니다. 추가적으로 보안이 필요한 경우 TLS와 같은 보안 프로토콜이 사용됩니다.

## 문제 2: HTTP의 Persistent Connection과 Non-Persistent Connection의 차이점을 설명하시오.

**Persistent Connection**과 **Non-Persistent Connection**은 HTTP 프로토콜에서 서버와 클라이언트 간의 연결 관리 방식을 정의합니다. 두 방식의 주요 차이점은 다음과 같습니다:

1. **Connection 유지 시간**:
    - **Non-Persistent Connection**:
        - 각 요청/응답 쌍에 대해 별도의 연결을 사용합니다. 클라이언트가 서버에 요청을 보내고 응답을 받은 후, 연결이 즉시 닫힙니다.
        - **예시**: 클라이언트가 웹 페이지의 각 요소(HTML, CSS, 이미지 등)에 대해 개별적으로 연결을 설정하고 종료합니다.
    - **Persistent Connection**:
        - 여러 요청/응답 쌍을 위해 단일 연결을 재사용합니다. 초기 연결 설정 후, 일정 시간 동안 연결이 유지되며 여러 개의 요청과 응답이 그 연결을 통해 전송됩니다.
        - **예시**: 클라이언트가 웹 페이지를 요청하고, 그 페이지에 포함된 여러 요소들을 같은 연결을 통해 순차적으로 요청합니다.

2. **연결 설정 및 종료 비용**:
    - **Non-Persistent Connection**:
        - 각 요청마다 새로운 TCP 연결을 설정하고 종료하기 때문에, 연결 설정과 종료에 따른 오버헤드가 큽니다.
        - **비용**: TCP 3-way handshake와 연결 종료를 위한 추가 시간 소모.
    - **Persistent Connection**:
        - 한 번의 연결 설정으로 여러 요청을 처리하기 때문에, 연결 설정과 종료에 따른 오버헤드가 감소합니다.
        - **비용 절감**: 연결 설정과 종료의 빈도가 줄어들어 네트워크 효율성이 높아집니다.

3. **지연 시간**:
    - **Non-Persistent Connection**:
        - 매 요청마다 새로운 연결을 설정하므로, 지연 시간이 증가합니다.
        - **지연 요소**: 각 요청마다 TCP 연결 설정 지연 발생.
    - **Persistent Connection**:
        - 이미 설정된 연결을 재사용하므로, 지연 시간이 감소합니다.
        - **지연 감소**: 연결 설정 시간 없이 바로 데이터 전송 가능.

4. **HTTP/1.0 vs HTTP/1.1**:
    - **Non-Persistent Connection**:
        - 기본적으로 HTTP/1.0에서 사용됩니다. HTTP/1.0은 각 요청마다 새로운 연결을 사용합니다.
        - **사용 버전**: HTTP/1.0
    - **Persistent Connection**:
        - HTTP/1.1에서 기본 설정입니다. HTTP/1.1은 연결을 지속적으로 유지하도록 설계되었습니다.
        - **사용 버전**: HTTP/1.1

5. **서버 부하**:
    - **Non-Persistent Connection**:
        - 서버는 각 요청마다 새로운 연결을 처리해야 하므로 부하가 증가할 수 있습니다.
        - **부하 증가**: 많은 수의 연결 설정과 종료 처리 필요.
    - **Persistent Connection**:
        - 서버는 연결 수를 줄이고, 동일한 연결을 재사용하여 처리 부하를 줄일 수 있습니다.
        - **부하 감소**: 연결 설정 및 관리에 필요한 리소스 절약.

**요약**: Non-Persistent Connection은 각 요청마다 새로운 연결을 설정하여 오버헤드와 지연 시간이 크며, 서버 부하가 높습니다. 반면, Persistent Connection은 한 번 설정된 연결을 여러 요청에 재사용하여 오버헤드와 지연 시간을 줄이고, 서버 부하를 감소시킵니다. HTTP/1.1에서는 Persistent Connection이 기본 설정으로 사용됩니다.
